<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monetizelt</title>
    <link rel="icon" href="https://firebasestorage.googleapis.com/v0/b/monetizelt-b235d.firebasestorage.app/o/1000009017_resized.jpg?alt=media&token=d69084a3-b285-44e4-81a5-f05971314175">
    <link href="https://fonts.googleapis.com/css2?family=Billabong&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f5f5f5;
    color: #333;
}
header {
    background-color: #ffffff;
    padding: 10px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    position: sticky;
    top: 0;
    z-index: 10;
}
h1 {
    margin: 0;
    font-size: 1.7em;
    font-family: 'Billabong', cursive;
    color: #007BFF;
    border: 2px solid #007BFF;
    padding: 3px;
    border-radius: 13px;
}

.slogan {
    text-align: center;
    margin: 10px 0 5px 0;
    font-size: 1.2em;
    color: #007BFF;
    padding: 10px;
    border: 1px solid #007BFF;
    border-radius: 20px;
    background-color: #e9f5ff;
}

.icon-container {
    display: flex;
    align-items: center;
}
.icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 31px;
    height: 31px;
    border: 1px solid #007BFF; 
    border-radius: 11px;
    background-color: white;
    color: #007BFF;
    margin-left: 5px; 
    cursor: pointer;
    transition: background-color 0.3s;
}
.icon:hover {
    background-color: #e9f5ff; 
}
.divider {
    height: 1px;
    background-color: #007BFF;
    width: 100%;
    margin: 0; 
}
.button-container {
    display: flex;
    justify-content: center;
    padding: 4px 0;
    overflow-x: auto;
    white-space: nowrap;
    margin: 0 0 5px 0;
    max-width: 100%;
}
.button-container a {
    margin: 0 5px;
    display: flex;
    align-items: center;
    text-decoration: none;
    flex-shrink: 0;
}
.button-container a i {
    margin-right: 5px;
}
.button {
    background-color: #007BFF;
    color: white;
    border: none;
    border-radius: 15px;
    padding: 8px 15px;
    font-size: 0.9em;
    cursor: pointer;
    transition: background-color 0.3s;
    white-space: nowrap;
    text-align: center;
    min-width: 70px;
}
.button:hover {
    background-color: #0056b3;
}
.footer-button {
    margin-left: 10px;
}
a {
    text-decoration: none;
}
.dashboard { 
    max-width: 800px; 
    margin: auto; 
    padding: 5px 10px;
}
.grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 5px;
}
.card {
    background: white;
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    text-align: center;
    text-decoration: none;
    color: inherit;
    border: 1px solid #007BFF;
    transition: background 0.3s, transform 0.2s;
    position: relative;
}
.small-card { height: 50px; }
.card:hover {
    transform: translateY(-2px);
    background: #e9f5ff;
}
.title { color: #666; font-size: 0.6rem; margin-bottom: 5px;font-family: "Poppins", sans-serif; }
.value { font-size: 0.3rem; font-weight: bold; color: #007BFF; margin-top: 5px; }
.value-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
}
.trend-indicator {
    margin-top: 5px;
    margin-left: 4px;
    font-size: 0.6rem;
}
.trend-up {
    color: #4CAF50;
}
.trend-down {
    color: #F44336;
}
.trend-neutral {
    color: #FFC107;
}
.history { 
    border-top: 3px solid #007BFF; 
    grid-column: 1/-1; 
    max-height: 200px;
    overflow-y: auto; 
}
.transaction-item {
    display: flex;
    justify-content: space-between;
    padding: 10px;
    border-radius: 10px;
    margin: 5px 0;
    background-color: #f0f8ff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    transition: background-color 0.3s;
}
.transaction-item:hover {
    background-color: #e6f7ff;
}
.history-item .details {
    display: flex;
    justify-content: space-between;
    flex-grow: 1;
}
.date { margin-left: 10px; color: #888; font-size: 0.9rem; }
.no-transactions {
    font-size: 0.8em;
    color: #888;
    text-align: center;
    padding: 5px;
}
.payment-status {
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 0.7em;
    padding: 2px 5px;
    border-radius: 10px;
    color: white;
    z-index: 1;
}

.payment-status.not-active {
    background-color: #F44336;
}

.payment-status.active {
    background-color: #4CAF50;
}

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: white;
    border-radius: 20px;
    width: 90%;
    max-width: 450px;
    padding: 18px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    text-align: center;
    max-height: 90vh;
    overflow-y: auto;
}

.delete-button {
    background-color: #F44336;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 10px 15px;
    font-size: 1em;
    cursor: pointer;
    transition: background-color 0.3s;
    width: 100%;
    margin-top: 10px;
}

.delete-button:hover {
    background-color: #ff3333;
}

.confirm-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1001;
    justify-content: center;
    align-items: center;
}

.confirm-modal-content {
    background-color: white;
    border-radius: 20px;
    width: 280px;
    padding: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    border: 1.5px solid #007BFF;
}

.modal-title {
    font-size: 1.2em;
    font-weight: bold;
    margin-bottom: 15px;
    color: #333;
}

.modal-message {
    margin-bottom: 15px;
    color: #555;
    font-size: 0.9em;
}

.email-input,
.password-input {
    width: 100%;
    padding: 10px;
    margin: 8px 0;
    border: 1px solid #ddd;
    border-radius: 10px;
    font-size: 0.9em;
    box-sizing: border-box;
}

.confirm-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    margin-top: 20px;
}

.confirm-delete {
    background-color: #F44336;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 10px 15px;
    cursor: pointer;
    flex: 1;
    font-weight: bold;
}

.cancel-delete {
    background-color: #007BFF;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 10px 15px;
    cursor: pointer;
    flex: 1;
}

.toast-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1005;
}

.toast {
    background-color: #333;
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    margin-top: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    animation: slideIn 0.3s ease, fadeOut 0.5s ease 2.5s forwards;
    max-width: 300px;
}

.toast.success {
    background-color: #4CAF50;
}

.toast.error {
    background-color: #F44336;
}

.toast.info {
    background-color: #2196F3;
}

.toast-icon {
    margin-right: 10px;
    font-size: 20px;
}

.button.disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    opacity: 0.7;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
    }
}

.pulse-animation {
    animation: pulse 2s infinite;
}

.payment-warning {
    color: #F44336;
    font-size: 0.8rem;
    margin-top: 5px;
    display: none;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
    }
    to {
        opacity: 0;
        display: none;
    }
}

/* DÉBUT DES CORRECTIFS POUR LE MODAL CREATE NEW PRODUCT */
.create-product-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.product-modal-content {
    background-color: white;
    border-radius: 20px;
    width: 90%;
    max-width: 450px;
    padding: 15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    box-sizing: border-box;
    border: 1.8px solid #007bff;
}

.product-modal-title {
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 12px;
    color: #007BFF;
    text-align: center;
    border-bottom: 2px solid #e9f5ff;
    padding-bottom: 8px;
}

.form-group {
    margin-bottom: 10px;
}

.form-label {
    display: block;
    margin-bottom: 3px;
    font-weight: bold;
    color: #555;
    font-size: 0.8em;
}

/* Modifications importantes pour les champs sur iOS */
.form-control {
    width: 100%;
    padding: 7px;
    border: 1px solid #007BFF;
    border-radius: 10px;
    font-size: 16px !important; /* iOS évite le zoom à cette taille */
    box-sizing: border-box;
    appearance: none;
    -webkit-appearance: none;
    max-height: 38px;
    min-height: 38px;
    transform: scale(1);
    transform-origin: top left;
    /* Ces propriétés empêchent le zoom sur iOS */
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
}

.form-control:focus {
    border-color: #007BFF;
    outline: none;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    font-size: 16px !important;
}

.form-select {
    width: 100%;
    padding: 7px;
    border: 1px solid #007BFF;
    border-radius: 10px;
    font-size: 16px !important;
    background-color: white;
    box-sizing: border-box;
    appearance: none;
    -webkit-appearance: none;
    max-height: 38px;
    min-height: 38px;
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
}

.character-count {
    font-size: 0.7em;
    color: #888;
    text-align: right;
    margin-top: 3px;
}

.file-upload-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 10px;
}

.file-upload-box {
    border: 2px dashed #007BFF;
    border-radius: 10px;
    padding: 10px;
    text-align: center;
    cursor: pointer;
    transition: background-color 0.3s;
    height: 60px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
}

.file-upload-box:hover {
    background-color: #e9f5ff;
}

.file-upload-icon {
    font-size: 18px;
    color: #007BFF;
    margin-bottom: 3px;
}

.file-upload-text {
    font-size: 0.7em;
    color: #555;
}

.file-upload-input {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    opacity: 0;
    cursor: pointer;
    font-size: 0;  /* Empêche le changement de taille sur iOS */
}

.file-name {
    font-size: 0.7em;
    color: #4CAF50;
    margin-top: 3px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    display: none;
}

.create-product-button {
    background-color: #007BFF;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 8px;
    font-size: 0.85em;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
    margin-top: 12px;
    transition: background-color 0.3s;
    /* Prévenir le redimensionnement sur iOS */
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
}

.create-product-button:hover {
    background-color: #0056b3;
}

.create-product-button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.cancel-button {
    background-color: #f5f5f5;
    color: #555;
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 7px;
    font-size: 0.8em;
    cursor: pointer;
    width: 100%;
    margin-top: 7px;
    transition: background-color 0.3s;
    /* Prévenir le redimensionnement sur iOS */
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
}

.cancel-button:hover {
    background-color: #e9e9e9;
}

.price-input-container {
    position: relative;
}

.price-input-container::before {
    content: "$";
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: #666;
}

.price-input {
    padding-left: 22px !important;
}

.upload-success-icon {
    color: #4CAF50;
    display: none;
}

.price-calculation {
    font-size: 0.7em;
    margin-top: 5px;
    padding: 5px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #eee;
    text-align: left;
}

.price-calculation-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 2px;
}

.price-calculation-total {
    font-weight: bold;
    border-top: 1px solid #ddd;
    padding-top: 2px;
    margin-top: 2px;
}

.price-calculation-note {
    font-size: 0.8em;
    color: #666;
    margin-top: 3px;
    font-style: italic;
}
/* FIN DES CORRECTIFS POUR LE MODAL CREATE NEW PRODUCT */

.splash-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 12px;
    z-index: 10;
}

.data-loader {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.skeleton-loader {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 8px;
    height: 100%;
    width: 100%;
}

@keyframes loading {
    0% {
        background-position: 200% 0;
    }
    100% {
        background-position: -200% 0;
    }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.links-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.links-modal-content {
    background-color: white;
    border-radius: 20px;
    width: 92%;
    max-width: 500px;
    padding: 15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    max-height: 80vh;
    overflow-y: auto;
    border: 1.7px solid #007bff; /* Ajout de la bordure de 1.7px */
}

.links-modal-title {
    font-size: 1em;
    font-weight: bold;
    margin-bottom: 12px;
    color: #007BFF;
    text-align: center;
    border-bottom: 1px solid #e9f5ff;
    padding-bottom: 8px;
}

.link-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 7px;
    border: 1px solid #007BFF;
    border-radius: 10px;
    margin-bottom: 7px;
    background-color: #f9f9f9;
    height: 18px;
}

.link-number {
    font-weight: bold;
    color: #007BFF;
    margin-right: 8px;
    font-size: 0.8em;
}

.link-url {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #333;
    font-size: 0.75em;
}

.share-link-btn {
    border-radius: 37%;
    background-color: #007BFF;
    border: none;
    color: white;
    cursor: pointer;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.share-link-btn:hover {
    background-color: #0056b3;
}

.paypal-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.paypal-modal-content {
    background-color: white;
    border-radius: 20px;
    width: 85%;
    max-width: 300px;
    padding: 15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    border: 1px solid #007BFF;
}

.paypal-modal-title {
    font-size: 1em;
    font-weight: bold;
    margin-bottom: 10px;
    color: #007BFF;
    text-align: center;
}

.paypal-form-group {
    margin-bottom: 10px;
}

.paypal-form-label {
    display: block;
    margin-bottom: 3px;
    font-weight: bold;
    color: #555;
    font-size: 0.8em;
}

/* Correctif pour les champs PayPal sur iOS */
.paypal-form-control {
    width: 100%;
    padding: 7px;
    border: 1px solid #ddd;
    border-radius: 10px;
    font-size: 16px !important;
    box-sizing: border-box;
    appearance: none;
    -webkit-appearance: none;
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
}

.paypal-form-control:focus {
    border-color: #007BFF;
    outline: none;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.paypal-submit-btn {
    background-color: #007BFF;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 8px;
    font-size: 0.85em;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
    transition: background-color 0.3s;
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
}

.paypal-submit-btn:hover {
    background-color: #0056b3;
}

.paypal-submit-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.paypal-modal-message {
    margin-bottom: 12px;
    color: #555;
    font-size: 0.75em;
    line-height: 1.4;
}

.paypal-error {
    color: #F44336;
    font-size: 0.7em;
    margin-top: 3px;
    display: none;
}

.sold-transaction {
    border-left: 3px solid #4CAF50 !important;
}

.payout-transaction {
    border-left: 3px solid #2196F3 !important;
}

.spinner {
    border: 3px solid rgba(0, 123, 255, 0.3);
    border-radius: 50%;
    border-top: 3px solid #007BFF;
    width: 18px;
    height: 18px;
    animation: spin 1s linear infinite;
    display: inline-block;
    margin-right: 7px;
}

.link-title {
    color: #007BFF !important;
    font-weight: bold;
}

.file-disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Correctif pour le textarea description */
#productDescription {
    height: 70px;
    resize: vertical;
    font-size: 16px !important;
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
    min-height: 70px;
    max-height: 120px;
    padding: 7px;
    line-height: 1.3;
}

/* Animation de chargement en 3 points */
.loading-dots {
    display: inline-block;
}

.loading-dots:after {
    content: '...';
    animation: dots 1.5s steps(5, end) infinite;
    display: inline-block;
    width: 18px;
    text-align: left;
}

@keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
}

/* Transaction container avec hauteur fixe */
#transactionList {
    max-height: 180px;
    overflow-y: auto;
    overscroll-behavior: contain;
}

/* Amélioration du bouton de partage */
.share-icon-text {
    font-size: 0.6em;
    display: block;
    margin-top: 2px;
}

/* Overlay de chargement pour la génération de liens */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.loading-message {
    margin-top: 15px;
    font-size: 1em;
    color: #007BFF;
}

/* Sélecteur de période avec flèches */
.period-selector {
    height: 35px; 
    border-left: 1px solid #007bff;
    border-right: 1px solid #007bff;
    border-bottom: 1px solid #007bff;
    border-top: 3px solid #007BFF;
    margin-top: 0;
    margin-bottom: 5px;
    width: 97%;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-radius: 13px;
    background: white;
    position: relative;
}

.period-arrow {
    width: 27px;
    height: 27px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #007bff;
    cursor: pointer;
    font-size: 0.8rem;
}

.period-arrow:hover {
    background-color: #e9f5ff;
    border-radius: 50%;
}

.period-arrow.left {
    margin-left: 10px;
}

.period-arrow.right {
    margin-right: 10px;
}

.period-loader {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

.gear-icon {
    color: #007bff;
    font-size: 1.2rem;
    animation: spin 2s linear infinite;
}

/* Style pour l'affichage de la période actuelle */
.current-period {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: #007bff;
    font-weight: bold;
    font-size: 0.9rem;
}

/* Overlay amélioré pour la génération de produit */
.generation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.95);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.generation-spinner {
    width: 45px;
    height: 45px;
    border: 4px solid rgba(0, 123, 255, 0.2);
    border-radius: 50%;
    border-top-color: #007bff;
    animation: spin 1s linear infinite;
}

.generation-message {
    margin-top: 18px;
    font-size: 1.1em;
    color: #007BFF;
    font-weight: bold;
}

.generation-step {
    margin-top: 8px;
    font-size: 0.85em;
    color: #666;
}

/* Ajout d'une bordure pour le modal de succès après génération de liens */
.confirm-modal-content.success-modal {
    border: 1.7px solid #007bff;
}

/* Media queries pour la responsivité */
@media (max-width: 500px) {
    .grid { grid-template-columns: repeat(2, 1fr); }
    .title { font-size: 0.6rem; }
    .value { font-size: 1.1rem; }
    
    .button-container {
        justify-content: space-between;
        padding: 4px 10px;
    }
    
    .button {
        padding: 6px 10px;
        margin: 0 2px;
        min-width: 60px;
    }
    
    .modal-content {
        width: 80%;
        max-width: 250px;
    }
    
    .confirm-modal-content {
        width: 85%;
        max-width: 280px;
        padding: 15px;
    }
    
    .delete-button {
        font-size: 0.9em;
    }
    
    .toast {
        max-width: 250px;
        left: 20px;
        right: 20px;
    }
    
    /* Correctifs spécifiques au modal de création de produit sur mobile */
    .product-modal-content {
        width: 92%;
        padding: 12px;
        max-height: 95vh;
    }
    
    .file-upload-container {
        grid-template-columns: 1fr;
    }
    
    .paypal-modal-content {
        width: 90%;
        padding: 12px;
        max-width: 280px;
    }
    
    .links-modal-content {
        width: 92%;
        padding: 12px;
        max-width: 300px;
    }
    
    /* Correctifs pour l'en-tête sur iPhone */
    header, h1, .icon, .icon-container {
        max-width: 100%;
        box-sizing: border-box;
    }
    
    h1 {
        font-size: 1.5em;
        padding: 3px 6px;
    }
    
    .icon {
        width: 28px;
        height: 28px;
    }
    
    .icon i {
        font-size: 18px !important;
    }
    
    /* Correctifs importants pour les champs dans le modal sur iPhone */
    .form-control, .form-select, .paypal-form-control {
        font-size: 16px !important; /* Empêche le zoom sur iOS */
        transform: scale(1);
        transform-origin: left top;
        box-sizing: border-box;
        text-size-adjust: none;
        -webkit-text-size-adjust: none;
    }
    
    /* Correction globale pour tous les champs de saisie */
    input, textarea, select {
        font-size: 16px !important;
        max-height: unset;
        text-size-adjust: none;
        -webkit-text-size-adjust: none;
    }
    
    /* Empêcher le zoom sur les différents types de champs */
    input[type="text"], 
    input[type="email"],
    input[type="password"],
    input[type="number"],
    textarea {
        font-size: 16px !important;
        transform: scale(1);
        text-size-adjust: none;
        -webkit-text-size-adjust: none;
    }
    
    /* Ajustements spécifiques pour le modal de création de produit */
    .product-modal-title {
        font-size: 1em;
        margin-bottom: 10px;
        padding-bottom: 7px;
    }
    
    .form-group {
        margin-bottom: 8px;
    }
    
    .form-label {
        font-size: 0.75em;
        margin-bottom: 2px;
    }
    
    /* Réduire la hauteur des zones de téléchargement de fichiers */
    .file-upload-box {
        height: 50px;
        padding: 8px;
    }
    
    .file-upload-text {
        font-size: 0.65em;
    }
    
    .file-upload-icon {
        font-size: 16px;
        margin-bottom: 2px;
    }
    
    /* Ajuster les boutons dans le modal */
    .create-product-button, .cancel-button {
        padding: 7px;
        margin-top: 10px;
        font-size: 0.8em;
        text-size-adjust: none;
        -webkit-text-size-adjust: none;
    }
}

/* Pour les très petits écrans */
@media (max-width: 320px) {
    h1 {
        font-size: 1.3em;
    }
    
    .icon {
        width: 26px;
        height: 26px;
        margin-left: 3px;
    }
    
    .button {
        padding: 5px 8px;
        font-size: 0.8em;
    }
    
    /* Garantir que les champs ne changent pas de taille sur les très petits écrans */
    .form-control, .form-select, .paypal-form-control {
        font-size: 16px !important;
        text-size-adjust: none;
        -webkit-text-size-adjust: none;
    }
    
    /* Réduire davantage la taille des éléments pour les très petits écrans */
    .product-modal-title {
        font-size: 0.9em;
    }
    
    .form-label {
        font-size: 0.7em;
    }
    
    .form-control, .form-select {
        max-height: 36px;
        min-height: 36px;
        padding: 6px;
    }
    
    #productDescription {
        height: 60px;
        min-height: 60px;
        max-height: 100px;
    }
    
    .file-upload-box {
        height: 45px;
        padding: 6px;
    }
    
    .create-product-button, .cancel-button {
        padding: 6px;
        font-size: 0.75em;
    }
}
    </style>

</head>
<body>
<header>
<h1 translate="no">Monetizelt</h1>
<div class="icon-container">
<div class="icon-container">
<a class="icon" id="linksIcon" href="javascript:void(0);" aria-label="View links">
<i class="fas fa-link" style="font-size: 23px;"></i>
</a>
<a class="icon" id="profileIcon" href="javascript:void(0);" aria-label="User profile">
<i class="fas fa-user" style="font-size: 23px;"></i>
</a>
</div>
</div>
</header>
<div class="divider"></div>
<div class="slogan">Your market, your rules! <br> Generate, share, cash in!</div>

<div class="button-container">
<a class="button button-explorer disabled" id="generateBtn" href="javascript:void(0);"><i class="fas fa-link"></i> Generate</a>
<a class="button" href="faq.html"><i class="fas fa-question-circle"></i> FAQ</a>
<a class="button" href="terms.html"><i class="fas fa-file-contract"></i> Terms</a>
<a class="button" href="privacy.html"><i class="fas fa-file-contract"></i> Privacy</a>
</div>
<div id="paymentWarning" class="payment-warning" style="text-align: center;">Update your payment method to start generating links</div>
  
<div class="dashboard">
<div class="period-selector" id="periodSelector">
    <div class="period-loader">
        <i class="fas fa-cog gear-icon" id="periodLoaderIcon"></i>
    </div>
    <div class="current-period" id="currentPeriod"></div>
</div>

<div class="grid">
<div class="card liens-generes small-card">
<div class="data-loader" id="linksCountLoader">
<div class="skeleton-loader"></div>
</div>
<div class="title">Generated Links</div>
<div class="value-wrapper">
<div class="value" id="linksCount" style="font-size: 0.8em;">0</div>
<span id="linksIndicator" class="trend-indicator"></span>
</div>
</div>
<div class="card vues small-card">
<div class="data-loader" id="viewsCountLoader">
<div class="skeleton-loader"></div>
</div>
<div class="title">Views</div>
<div class="value-wrapper">
<div class="value" id="viewsCount" style="font-size: 0.8em;">0</div>
<span id="viewsIndicator" class="trend-indicator"></span>
</div>
</div>
<div class="card commandes small-card">
<div class="data-loader" id="ordersCountLoader">
<div class="skeleton-loader"></div>
</div>
<div class="title">Orders</div>
<div class="value-wrapper">
<div class="value" id="ordersCount" style="font-size: 0.8em;">0</div>
<span id="ordersIndicator" class="trend-indicator"></span>
</div>
</div>
<div class="card traite small-card">
<div class="data-loader" id="shippedCountLoader">
<div class="skeleton-loader"></div>
</div>
<div class="title">Processed</div>
<div class="value-wrapper">
<div class="value" id="shippedCount" style="font-size: 0.8em;">0</div>
<span id="shippedIndicator" class="trend-indicator"></span>
</div>
</div>
<div class="card revenus small-card">
<div class="data-loader" id="revenueCountLoader">
<div class="skeleton-loader"></div>
</div>
<div class="title">Income</div>
<div class="value-wrapper">
<div class="value" id="revenueCount" style="font-size: 0.8em;">0$</div>
<span id="revenueIndicator" class="trend-indicator"></span>
</div>
</div>
<a class="card paiement small-card pulse-animation" id="paypalCard" href="javascript:void(0);" aria-label="PayPal Configuration">
<div class="data-loader" id="paypalStatusLoader">
<div class="skeleton-loader"></div>
</div>
<span class="payment-status not-active" id="paypalStatus">Not Active</span>
<div class="title">Payments</div>
<i class="fab fa-paypal" style="font-size: 1.2em; color: #007BFF;"></i>
</a>
<div class="card history">
<div class="data-loader" id="transactionLoader">
<div class="skeleton-loader"></div>
</div>
<div class="title">Transactions</div>
<div id="transactionList" style="max-height: 300px; overflow-y: auto;">
<div class="no-transactions">No transactions</div>
</div>
</div>
</div>
</div>

<div id="deleteModal" class="modal">
<div class="modal-content">
<div class="modal-title">Account Options</div>
<button id="deleteAccountBtn" class="delete-button">Delete Account</button>
</div>
</div>

<div id="confirmModal" class="confirm-modal">
<div class="confirm-modal-content">
<div class="modal-title">Confirm Account Deletion</div>
<div class="modal-message">This action cannot be undone. All your data will be permanently removed.</div>
<input type="email" id="emailInput" class="email-input" placeholder="Your email">
<input type="password" id="passwordInput" class="password-input" placeholder="Your password">
<div class="confirm-buttons">
<button id="confirmDeleteBtn" class="confirm-delete">Delete</button>
<button id="cancelDeleteBtn" class="cancel-delete">Cancel</button>
</div>
</div>
</div>

<div id="createProductModal" class="create-product-modal">
<div class="product-modal-content">
<div class="product-modal-title">Create New Product</div>

<div class="form-group">
<label for="productTitle" class="form-label">Title</label>
<input type="text" id="productTitle" class="form-control" placeholder="Enter product title">
</div>

<div class="form-group">
<label for="productCategory" class="form-label">Category</label>
<select id="productCategory" class="form-select">
<option value="">Select a category</option>
<option value="video">Video Content</option>
</select>
</div>

<div class="form-group">
<label for="productDescription" class="form-label">Description</label>
<textarea id="productDescription" class="form-control" placeholder="... " maxlength="500"></textarea>
<div class="character-count"><span id="descriptionCharCount">0</span>/500</div>
</div>

<div class="form-group">
<label for="productPrice" class="form-label">Price ($)</label>
<div class="price-input-container">
<input type="number" id="productPrice" class="form-control price-input" placeholder="Enter price" min="0.01" step="0.01">
</div>
<div id="priceCalculation" class="price-calculation" style="display:none;">
<div class="price-calculation-item">
<span>Base price:</span>
<span id="basePrice">$0.00</span>
</div>
<div class="price-calculation-item">
<span>Referral fee (12%):</span>
<span id="referralFee">$0.00</span>
</div>
<div class="price-calculation-item">
  <span>Transaction fee (2.9% + $0.30):</span>
  <span id="transactionFee">$0.00</span>
</div>
<div class="price-calculation-item price-calculation-total">
<span>Your earnings:</span>
<span id="sellerEarnings">$0.00</span>
</div>
</div>
</div>

<div class="form-group">
<label class="form-label">Files</label>
<div class="file-upload-container">
<div class="file-upload-box" id="coverUploadBox">
<i class="fas fa-image file-upload-icon"></i>
<span class="file-upload-text">Cover Image</span>
<input type="file" id="coverFile" class="file-upload-input" accept="image/*">
<i class="fas fa-check-circle upload-success-icon" id="coverSuccessIcon"></i>
<div class="file-name" id="coverFileName"></div>
<div class="upload-progress-container" id="coverProgressContainer" style="display: none;">
  <div class="upload-progress-bar" id="coverProgressBar"></div>
</div>
</div>

<div class="file-upload-box file-disabled" id="productFileUploadBox">
<i class="fas fa-file file-upload-icon" id="productFileIcon"></i>
<span class="file-upload-text">Product File</span>
<input type="file" id="productFile" class="file-upload-input" disabled>
<i class="fas fa-check-circle upload-success-icon" id="productFileSuccessIcon"></i>
<div class="file-name" id="productFileName"></div>
<div class="upload-progress-container" id="productProgressContainer" style="display: none;">
  <div class="upload-progress-bar" id="productProgressBar"></div>
</div>
</div>
</div>
<div class="character-count" id="fileUploadLimits">Please select a category first</div>
</div>

<button id="createProductBtn" class="create-product-button">Generate Link</button>
<button id="cancelProductBtn" class="cancel-button">Cancel</button>
</div>
</div>

<div id="linksModal" class="links-modal">
<div class="links-modal-content">
<div class="links-modal-title">Generated Links</div>
<div id="linksList">
<div style="text-align: center; color: #888;">No links generated yet</div>
</div>
<button id="closeLinksModal" class="cancel-button" style="margin-top: 15px;">Close</button>
</div>
</div>

<div id="confirmDeleteProductModal" class="confirm-modal">
<div class="confirm-modal-content">
<div class="modal-title">Confirm Product Deletion</div>
<div class="modal-message">Are you sure you want to delete this product? This action cannot be undone.</div>
<div class="confirm-buttons">
<button id="cancelDeleteProductBtn" class="cancel-delete">Cancel</button>
<button id="confirmDeleteProductBtn" class="confirm-delete">Delete</button>
</div>
</div>
</div>

<div id="paypalModal" class="paypal-modal">
<div class="paypal-modal-content">
<div class="paypal-modal-title">PayPal Account Setup</div>
<div class="paypal-modal-message">
Please check and register your PayPal email address to receive your payments every Friday
if your balance reaches a minimum of $10.
</div>
<div class="paypal-form-group">
<label for="paypalEmail" class="paypal-form-label">PayPal Email</label>
<input type="email" id="paypalEmail" class="paypal-form-control" placeholder="your@email.com">
<div id="paypalEmailError" class="paypal-error">Please enter a valid email address</div>
</div>
<button id="savePaypalBtn" class="paypal-submit-btn">Save</button>
</div>
</div>

<!-- Improved product generation overlay -->
<div id="generationOverlay" class="generation-overlay" style="display: none;">
<div class="progress-container">
  <div class="progress-bar" id="generationProgressBar"></div>
</div>
<div class="generation-message">Please wait...</div>
<div class="generation-step" id="generationStep">Preparing files...</div>
</div>

<div id="toastContainer" class="toast-container"></div>

<script type="module">
// Import Firebase modules
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, onAuthStateChanged, EmailAuthProvider, reauthenticateWithCredential, deleteUser } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, query, where, orderBy, limit, onSnapshot, serverTimestamp, getDocs, deleteDoc, Timestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

// Firebase configuration
const firebaseConfig = {
apiKey: "AIzaSyAF4I7E6-_z8y_8n8P35zyKbh9WOEtIzMQ",
authDomain: "monetizelt-b235d.firebaseapp.com",
projectId: "monetizelt-b235d",
storageBucket: "monetizelt-b235d.firebasestorage.app",
messagingSenderId: "1040211471009",
appId: "1:1040211471009:web:321898c7bdca6258ce9ee0",
measurementId: "G-5NWKR1E9VY"
};

// Base URL for API
const API_BASE_URL = "https://us-central1-monetizelt-b235d.cloudfunctions.net";
const PRODUCT_BASE_URL = "https://www.g-z.online/product.html?productId=";

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

// Application variables
let currentUserData = null;
let previousUserData = null;
let realTimeListeners = [];
let isInitialLoad = true;
let dataLoaded = false;
let userIdToken = null;
let paypalAccountComplete = false;
let generatedLinks = [];
let coverFile = null;
let productFile = null;
let coverFileUrl = null;
let productFileUrl = null;
let refreshInterval;
let isSubmitting = false;
let pendingUpdates = {}; // Cache for updates
let cacheDuration = 5000; // Cache duration reduced to 5s for faster response
let lastDataRefresh = 0;
let debounceTimers = {};
let tokenRefreshCount = 0;
let lastOrdersRefresh = 0;
let directDbRefresh = true; // Force direct DB refresh for critical data
let productClickCount = {}; // Track clicks for product deletion
let isRequestingStats = false; // Flag pour suivre si une demande de stats est en cours
let isProductCreationInProgress = false; // Variable pour suivre si un produit est en cours de création
let lastTransactions = []; // Mémoriser les dernières transactions pour éviter de les perdre

// File type icons map for product file
const fileTypeIcons = {
  video: "fas fa-video",
  ebook: "fas fa-book",
  music: "fas fa-music",
  software: "fas fa-code"
};

// File extensions allowed by category
const allowedExtensions = {
  video: ["mp4", "mov", "avi", "webm", "mkv"],
  ebook: ["pdf", "epub"],
  music: ["mp3", "wav", "ogg", "flac"],
  software: ["zip", "rar", "7z", "tar", "gz"]
};

// Helper function to get the start of the current year
function getStartOfYear(date) {
  const d = new Date(date);
  return new Date(d.getFullYear(), 0, 1);
}

// Helper function to get the end of the current year
function getEndOfYear(date) {
  const d = new Date(date);
  return new Date(d.getFullYear(), 11, 31, 23, 59, 59, 999);
}

// Helper function to format decimal places
function formatCurrency(amount) {
  if (typeof amount !== 'number') {
    amount = parseFloat(amount) || 0;
  }
  return amount.toFixed(2);
}

// Get valid authentication token
async function getValidToken() {
try {
const user = auth.currentUser;
if (!user) throw new Error("User not authenticated");

// Force token refresh if we've had errors
if (tokenRefreshCount > 0) {
userIdToken = await user.getIdToken(true);
console.log("Token forcefully refreshed");
} else {
userIdToken = await user.getIdToken();
}

return userIdToken;
} catch (error) {
console.error("Error getting valid token:", error);
throw error;
}
}

// API request helper with error handling
async function apiRequest(endpoint, method = 'GET', body = null) {
try {
const token = await getValidToken();

const options = {
method,
headers: {
'Authorization': `Bearer ${token}`,
'Content-Type': 'application/json'
}
};

if (body) {
options.body = JSON.stringify(body);
}

// Add UID to query parameters for GET requests
let url = `${API_BASE_URL}/${endpoint}`;
if (method === 'GET' && !url.includes('uid=') && auth.currentUser) {
const separator = url.includes('?') ? '&' : '?';
url += `${separator}uid=${auth.currentUser.uid}`;
}

const response = await fetch(url, options);

if (!response.ok) {
// Token might be expired, try refreshing once
if (response.status === 401 || response.status === 403) {
tokenRefreshCount++;
if (tokenRefreshCount <= 1) {
console.log("Retrying with new token...");
return apiRequest(endpoint, method, body);
}
}

const errorData = await response.json().catch(() => ({
error: `API request failed with status ${response.status}`
}));

throw new Error(errorData.error || `API request failed with status ${response.status}`);
}

// Reset token refresh counter on success
tokenRefreshCount = 0;

return await response.json();
} catch (error) {
console.error(`API request error (${endpoint}):`, error);
throw error;
}
}

// Optimization function - Debounce to prevent excessive function calls
function debounce(fn, delay) {
return function(...args) {
const fnKey = fn.toString();
clearTimeout(debounceTimers[fnKey]);
debounceTimers[fnKey] = setTimeout(() => fn.apply(this, args), delay);
};
}

// Function to convert file to base64 with optimized handling
function toBase64(file) {
return new Promise((resolve, reject) => {
// For smaller files, direct conversion
const reader = new FileReader();
reader.readAsDataURL(file);
reader.onload = () => resolve(reader.result);
reader.onerror = error => reject(error);
});
}

// Optimized function to display loaders
function showDataLoader(elementId, show = true) {
const loaderElement = document.getElementById(elementId);
if (loaderElement) {
loaderElement.style.display = show ? 'flex' : 'none';
}
}

// Display all loaders efficiently
function showAllDataLoaders(show = true) {
const loaderIds = ['linksCountLoader', 'viewsCountLoader', 'ordersCountLoader',
'shippedCountLoader', 'revenueCountLoader', 'transactionLoader', 'paypalStatusLoader'];

requestAnimationFrame(() => {
loaderIds.forEach(id => showDataLoader(id, show));
});
}

// Show stats request animation (gear spinning)
function showStatsRequest(show = true) {
  const loaderIcon = document.getElementById('periodLoaderIcon');
  if (loaderIcon) {
    if (show) {
      loaderIcon.classList.add('spin-animation');
      isRequestingStats = true;
    } else {
      loaderIcon.classList.remove('spin-animation');
      isRequestingStats = false;
    }
  }
}

// Set up data refresh
function setupDataRefresh() {
clearInterval(refreshInterval);
refreshInterval = setInterval(() => {
if (auth.currentUser) {
lastDataRefresh = Date.now();
showAllDataLoaders(true);

// Use requestIdleCallback for better performance
if (window.requestIdleCallback) {
requestIdleCallback(() => {
refreshDashboardData(auth.currentUser.uid, true);
});
} else {
setTimeout(() => {
refreshDashboardData(auth.currentUser.uid, true);
}, 500);
}
}
}, 3600000); // Actualisation chaque 60 minutes
}

// Reset all trend indicators to empty state
function resetTrendIndicators() {
  const indicators = ['linksIndicator', 'viewsIndicator', 'ordersIndicator', 'shippedIndicator', 'revenueIndicator'];
  
  requestAnimationFrame(() => {
    indicators.forEach(id => {
      const indicator = document.getElementById(id);
      if (indicator) {
        indicator.className = 'trend-indicator';
        indicator.innerHTML = '';
      }
    });
  });
}

// Force direct refresh pour orders avec utilisation du balance
async function forceDirectOrdersRefresh(userId) {
try {
console.log("Forcing direct orders refresh");
if (!userId) return;

// Get all orders for this user directly from Firestore
const ordersCollection = collection(db, "orders");
const q = query(
  ordersCollection,
  where("sellerUid", "==", userId)
);

const querySnapshot = await getDocs(q);

let totalOrders = 0;
let shippedOrders = 0;
let hasSaleInLast24h = false;

const now = new Date();
const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

querySnapshot.forEach((doc) => {
const order = doc.data();
totalOrders++;

if (order.status === "shipped" || order.status === "delivered") {
shippedOrders++;
}

// Vérifier s'il y a eu une vente dans les dernières 24h
if (order.createdAt) {
  const orderDate = order.createdAt.toDate ? order.createdAt.toDate() : new Date(order.createdAt);
  if (orderDate >= oneDayAgo) {
    hasSaleInLast24h = true;
  }
}
});

// Récupérer le balance depuis la collection users
let userBalance = 0;
try {
  const userDocRef = doc(db, "users", userId);
  const userDoc = await getDoc(userDocRef);
  
  if (userDoc.exists()) {
    const userData = userDoc.data();
    userBalance = userData.balance || 0;
  }
} catch (error) {
  console.error("Error fetching user balance:", error);
}

// Update user stats directly with accurate data
const statsRef = doc(db, "userStats", userId);
const statsDoc = await getDoc(statsRef);

if (statsDoc.exists()) {
await updateDoc(statsRef, {
ordersCount: totalOrders,
shippedCount: shippedOrders,
revenueCount: userBalance, // Utilise le balance
lastUpdated: serverTimestamp()
});

// Update UI with fresh data
if (currentUserData) {
previousUserData = {...currentUserData};
currentUserData.ordersCount = totalOrders;
currentUserData.shippedCount = shippedOrders;
currentUserData.revenueCount = userBalance;
currentUserData.hasSaleInLast24h = hasSaleInLast24h;

// Afficher les flèches de tendance si vente dans les dernières 24h
updateCountWithImprovedTrend("ordersCount", "ordersIndicator", totalOrders, "", previousUserData?.ordersCount);
updateCountWithImprovedTrend("shippedCount", "shippedIndicator", shippedOrders, "", previousUserData?.shippedCount);
updateCountWithImprovedTrend("revenueCount", "revenueIndicator", parseFloat(formatCurrency(userBalance)), "$", previousUserData?.revenueCount);
}

console.log("Direct DB refresh completed: Orders:", totalOrders, "Shipped:", shippedOrders, "Balance:", formatCurrency(userBalance));
return true;
} else {
// Initialize stats if needed
await initializeUserStats(userId);
return await forceDirectOrdersRefresh(userId);
}
} catch (error) {
console.error("Error in direct orders refresh:", error);
return false;
}
}

// Get view counts directly from database pour l'année
async function forceDirectViewsRefresh(userId) {
try {
console.log("Forcing direct views refresh");
if (!userId) return;

// Get all products for this seller
const productsCollection = collection(db, "products");
const q = query(productsCollection, where("uid", "==", userId));
const querySnapshot = await getDocs(q);

// Get total view count across all products
let totalViews = 0;
let hasSaleInLast24h = currentUserData?.hasSaleInLast24h || false;

// Promise.all for parallel processing
const viewPromises = querySnapshot.docs.map(async (productDoc) => {
  const productId = productDoc.id;
  const viewsCollection = collection(db, "productViews");
  
  let viewsQuery = query(viewsCollection, where("productId", "==", productId));
  
  const viewsSnapshot = await getDocs(viewsQuery);
  return viewsSnapshot.size;
});

const viewCounts = await Promise.all(viewPromises);
totalViews = viewCounts.reduce((sum, count) => sum + count, 0);

// Update user stats with view count
const statsRef = doc(db, "userStats", userId);
const statsDoc = await getDoc(statsRef);

if (statsDoc.exists()) {
await updateDoc(statsRef, {
viewsCount: totalViews,
lastUpdated: serverTimestamp()
});

// Update UI
if (currentUserData) {
previousUserData = {...currentUserData};
currentUserData.viewsCount = totalViews;

// Afficher la flèche de tendance si vente dans les dernières 24h
updateCountWithImprovedTrend("viewsCount", "viewsIndicator", totalViews, "", previousUserData?.viewsCount);
}

console.log("Direct views refresh completed: Views:", totalViews);
return true;
} else {
// Initialize stats if needed
await initializeUserStats(userId);
return await forceDirectViewsRefresh(userId);
}
} catch (error) {
console.error("Error in direct views refresh:", error);
return false;
}
}

// Get links count for the year
async function getLinksCountForYear(userId) {
try {
  if (!userId) return 0;
  
  const productsCollection = collection(db, "products");
  const q = query(
    productsCollection,
    where("uid", "==", userId)
  );
  
  const querySnapshot = await getDocs(q);
  return querySnapshot.size;
} catch (error) {
  console.error("Error getting links count for year:", error);
  return 0;
}
}

// Get transactions for the year
async function getTransactionsForYear(userId) {
try {
  if (!userId) return [];
  
  const currentYear = new Date().getFullYear();
  const startOfYear = new Date(currentYear, 0, 1);
  const endOfYear = new Date(currentYear, 11, 31, 23, 59, 59, 999);
  
  const transactionsCollection = collection(db, "transactions");
  const q = query(
    transactionsCollection,
    where("userId", "==", userId),
    where("date", ">=", Timestamp.fromDate(startOfYear)),
    where("date", "<=", Timestamp.fromDate(endOfYear)),
    orderBy("date", "desc")
  );
  
  const querySnapshot = await getDocs(q);
  const transactions = querySnapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));
  
  // Mettre à jour lastTransactions pour mémoriser
  if (transactions && transactions.length > 0) {
    lastTransactions = transactions;
  }
  
  return transactions;
} catch (error) {
  console.error("Error getting transactions for year:", error);
  // Retourner lastTransactions en cas d'erreur
  return lastTransactions.length > 0 ? lastTransactions : [];
}
}

// Update period display pour année
function updatePeriodDisplay() {
const currentPeriodEl = document.getElementById('currentPeriod');
if (currentPeriodEl) {
  const currentYear = new Date().getFullYear();
  currentPeriodEl.textContent = ``;
}
}

// NOUVEAU: Fonction pour demander l'envoi des statistiques par email
async function requestStatsEmail() {
  if (isRequestingStats) return;
  
  try {
    const user = auth.currentUser;
    if (!user) {
      return;
    }
    
    // Afficher l'animation de chargement
    showStatsRequest(true);
    
    // Appeler l'API pour demander l'envoi des statistiques
    await apiRequest('requestStatsEmail', 'POST', { uid: user.uid });
    
    // Changer la couleur de l'engrenage en vert pendant 3 secondes
    const gearIcon = document.getElementById('periodLoaderIcon');
    if (gearIcon) {
      const originalColor = gearIcon.style.color;
      gearIcon.style.color = '#4CAF50'; // Vert
      
      // Revenir à la couleur originale après 3 secondes
      setTimeout(() => {
        gearIcon.style.color = '#007bff'; // Couleur originale
        showStatsRequest(false);
      }, 3000);
    }
    
  } catch (error) {
    console.error("Error requesting statistics email:", error);
    showStatsRequest(false);
  }
}

// Load annual data
async function loadAnnualData(userId) {
try {
  if (!userId) return;
  
  // Show loaders
  showAllDataLoaders(true);
  
  // Update period display
  updatePeriodDisplay();
  
  // Reset trend indicators
  resetTrendIndicators();
  
  // Get data for this year
  const [linksCount, transactions] = await Promise.all([
    getLinksCountForYear(userId),
    getTransactionsForYear(userId)
  ]);
  
  // Force direct database refresh
  await Promise.all([
    forceDirectOrdersRefresh(userId),
    forceDirectViewsRefresh(userId)
  ]);
  
  // Update transactions list
  if (transactions && transactions.length > 0) {
    updateTransactionList(transactions);
    lastTransactions = transactions;
  } else if (lastTransactions.length > 0) {
    updateTransactionList(lastTransactions);
  } else {
    updateTransactionList([]);
  }
  
  // Update links count
  if (currentUserData) {
    previousUserData = {...currentUserData};
    currentUserData.linksCount = linksCount;
    updateCountWithImprovedTrend("linksCount", "linksIndicator", linksCount, "", previousUserData?.linksCount);
  }
  
  // Hide loaders
  showAllDataLoaders(false);
  
} catch (error) {
  console.error("Error loading annual data:", error);
  showToast("Error loading data for this year", "error");
  showAllDataLoaders(false);
}
}

// Optimized dashboard data refresh avec transactions incluses
async function refreshDashboardData(userId, showLoaders = true) {
try {
const refreshStart = performance.now();

if (showLoaders) {
showAllDataLoaders(true);
}

// Force direct database refresh for critical data periodically
const now = Date.now();
const orderRefreshNeeded = now - lastOrdersRefresh > 10000; // Every 10 seconds
if (orderRefreshNeeded || directDbRefresh) {
await Promise.all([
forceDirectOrdersRefresh(userId),
forceDirectViewsRefresh(userId)
]);
lastOrdersRefresh = now;
directDbRefresh = false;
}

// Parallel data loading incluant les transactions
const [userData, linksData, transactions] = await Promise.all([
loadUserData(userId),
loadLinksData(userId),
getTransactionsForYear(userId)
]);

// Mettre à jour la liste des transactions
if (transactions && transactions.length > 0) {
updateTransactionList(transactions);
lastTransactions = transactions;
} else if (lastTransactions.length > 0) {
// Utiliser les transactions en mémoire si rien n'est retourné
updateTransactionList(lastTransactions);
}

if (showLoaders) {
showAllDataLoaders(false);
}

const refreshEnd = performance.now();
console.log(`Dashboard refresh completed in ${refreshEnd - refreshStart}ms`);
} catch (error) {
console.error("Error refreshing data:", error);
if (showLoaders) {
showAllDataLoaders(false);
}
}
}

// Optimized toast notifications
const toastQueue = [];
let isShowingToast = false;

function showToast(message, type = 'info') {
toastQueue.push({ message, type });
if (!isShowingToast) {
processToastQueue();
}
}

function processToastQueue() {
if (toastQueue.length === 0) {
isShowingToast = false;
return;
}

isShowingToast = true;
const { message, type } = toastQueue.shift();
const container = document.getElementById('toastContainer');
const toast = document.createElement('div');
toast.className = `toast ${type}`;

let icon = '';
if (type === 'success') {
icon = '<i class="fas fa-check-circle toast-icon"></i>';
} else if (type === 'error') {
icon = '<i class="fas fa-exclamation-circle toast-icon"></i>';
} else if (type === 'info') {
icon = '<i class="fas fa-info-circle toast-icon"></i>';
}

toast.innerHTML = `${icon}<div>${message}</div>`;
container.appendChild(toast);

setTimeout(() => {
toast.classList.add('toast-fade-out');
setTimeout(() => {
if (container.contains(toast)) {
container.removeChild(toast);
}
processToastQueue();
}, 300);
}, 2500);
}

// Optimized animation for value updates
function animateUpdate(element) {
if (!element) return;

// Use requestAnimationFrame to sync with render cycle
requestAnimationFrame(() => {
element.classList.add('pulse');
setTimeout(() => {
requestAnimationFrame(() => {
element.classList.remove('pulse');
});
}, 500);
});
}

// Email validation
function isValidEmail(email) {
return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(email || "").toLowerCase());
}

// Initialize user stats
async function initializeUserStats(userId) {
// Check if stats already exist in cache
if (pendingUpdates[`stats_${userId}`]) {
return false;
}

try {
const statsRef = doc(db, "userStats", userId);
const statsDoc = await getDoc(statsRef);

if (!statsDoc.exists()) {
// Create default document if it doesn't exist
await setDoc(statsRef, {
linksCount: 0,
viewsCount: 0,
ordersCount: 0,
shippedCount: 0,
revenueCount: 0,
lastUpdated: serverTimestamp()
});

console.log("User stats initialized for:", userId);
return true;
}
return false;
} catch (error) {
console.error("Error initializing user stats:", error);
return false;
}
}

// NOUVEAU: Fonction pour gérer les payouts automatiques
async function checkAndHandlePayout() {
try {
  const user = auth.currentUser;
  if (!user) return;
  
  // Vérifier s'il y a eu un payout récent depuis le backend
  const userDoc = await getDoc(doc(db, "users", user.uid));
  if (userDoc.exists()) {
    const userData = userDoc.data();
    
    // Si lastPayout est récent (dernières 24h), réinitialiser les données
    if (userData.lastPayout) {
      const lastPayoutDate = userData.lastPayout.toDate ? userData.lastPayout.toDate() : new Date(userData.lastPayout);
      const now = new Date();
      const timeDiff = now.getTime() - lastPayoutDate.getTime();
      const hoursDiff = timeDiff / (1000 * 3600);
      
      // Si le payout a eu lieu dans les dernières 24h, commencer une nouvelle semaine
      if (hoursDiff < 24) {
        console.log("Recent payout detected, refreshing data");
        
        // Actualiser l'interface
        await loadAnnualData(user.uid);
        
        showToast("Your account has been updated after a recent payout!", "success");
      }
    }
  }
} catch (error) {
  console.error("Error checking payout status:", error);
}
}

// PayPal account setup
async function setupPayPalAccount() {
// If the account is already set up, don't show the modal
if (paypalAccountComplete) {
return;
}

const paypalModal = document.getElementById('paypalModal');
const paypalEmail = document.getElementById('paypalEmail');
const paypalEmailError = document.getElementById('paypalEmailError');
const savePaypalBtn = document.getElementById('savePaypalBtn');

// Reset previous entries
paypalEmail.value = "";
paypalEmailError.style.display = "none";
savePaypalBtn.disabled = false;

// If user already has PayPal configured, pre-fill the email
if (currentUserData && currentUserData.paypalEmail) {
paypalEmail.value = currentUserData.paypalEmail;
}

paypalModal.style.display = "flex";
}

// Save PayPal email
const savePayPalEmail = debounce(async function() {
if (isSubmitting) return;

try {
const paypalEmail = document.getElementById('paypalEmail').value.trim();
const paypalEmailError = document.getElementById('paypalEmailError');
const savePaypalBtn = document.getElementById('savePaypalBtn');

if (!isValidEmail(paypalEmail)) {
paypalEmailError.style.display = "block";
return;
}

const user = auth.currentUser;
if (!user) {
showToast("Please log in to set up PayPal", "error");
return;
}

isSubmitting = true;
savePaypalBtn.disabled = true;
savePaypalBtn.innerHTML = '<span class="spinner"></span> Saving...';

showToast("Saving your PayPal email...", "info");

// Update UI immediately for responsiveness
document.getElementById('paypalModal').style.display = "none";

// Initialize user stats if needed
await initializeUserStats(user.uid);

// Update user data locally first for immediate response
if (currentUserData) {
previousUserData = {...currentUserData};
currentUserData.paypalEmail = paypalEmail;
}

updatePayPalUI(true);

// Use the API request helper
await apiRequest('updatePaypalEmail', 'POST', {
paypalEmail: paypalEmail,
uid: user.uid
});

// Update Firestore database
const userDocRef = doc(db, "users", user.uid);
await updateDoc(userDocRef, {
paypalEmail: paypalEmail
});

showToast("PayPal email saved successfully!", "success");

// Refresh dashboard data
await refreshDashboardData(user.uid, false);

} catch (error) {
console.error("Error saving PayPal email:", error);
showToast(`Error: ${error.message}`, "error");

// Restore previous state on error
const savePaypalBtn = document.getElementById('savePaypalBtn');
savePaypalBtn.disabled = false;
savePaypalBtn.innerHTML = 'Save';
} finally {
isSubmitting = false;
}
}, 200);

// Check PayPal status
async function checkPayPalStatus() {
try {
showDataLoader('paypalStatusLoader', true);
const user = auth.currentUser;
if (!user) return false;

// First check local data
if (currentUserData && currentUserData.paypalEmail) {
updatePayPalUI(true);
showDataLoader('paypalStatusLoader', false);
return true;
}

// Use the API request helper
try {
const data = await apiRequest('getUserPaypalStatus');

const isActive = data.onboardingComplete ||
(data.paypalEmail && data.paypalEmail.length > 0);

if (isActive) {
// Update local data
if (currentUserData) {
currentUserData.paypalEmail = data.paypalEmail;
}
updatePayPalUI(true);
showDataLoader('paypalStatusLoader', false);
return true;
} else {
updatePayPalUI(false);
showDataLoader('paypalStatusLoader', false);
return false;
}
} catch (error) {
// Fallback to Firestore check
const userDocRef = doc(db, "users", user.uid);
const userDoc = await getDoc(userDocRef);

if (userDoc.exists() && userDoc.data().paypalEmail) {
// Fallback to Firestore if API fails
if (currentUserData) {
currentUserData.paypalEmail = userDoc.data().paypalEmail;
}
updatePayPalUI(true);
showDataLoader('paypalStatusLoader', false);
return true;
}

updatePayPalUI(false);
showDataLoader('paypalStatusLoader', false);
return false;
}
} catch (error) {
console.error("Error checking PayPal status:", error);

// Fallback to check Firestore directly
try {
const user = auth.currentUser;
if (!user) return false;

const userDocRef = doc(db, "users", user.uid);
const userDoc = await getDoc(userDocRef);

const isActive = userDoc.exists() && userDoc.data().paypalEmail;

if (isActive && currentUserData) {
currentUserData.paypalEmail = userDoc.data().paypalEmail;
}

updatePayPalUI(isActive);
showDataLoader('paypalStatusLoader', false);
return isActive;
} catch (fallbackError) {
console.error("PayPal status fallback failed:", fallbackError);
updatePayPalUI(false);
showDataLoader('paypalStatusLoader', false);
return false;
}
}
}

// Update PayPal UI
function updatePayPalUI(isActive) {
const paypalStatus = document.getElementById('paypalStatus');
const paypalCard = document.getElementById('paypalCard');
const generateBtn = document.getElementById('generateBtn');
const paymentWarning = document.getElementById('paymentWarning');

paypalAccountComplete = isActive;

// Group DOM modifications to minimize reflows
requestAnimationFrame(() => {
if (isActive) {
paypalStatus.textContent = "Active";
paypalStatus.className = "payment-status active";
paypalCard.style.borderColor = "#4CAF50";
paypalCard.classList.remove("pulse-animation");
paypalCard.onclick = null;

generateBtn.classList.remove("disabled");
generateBtn.onclick = openProductModal;

paymentWarning.style.display = "none";
} else {
paypalStatus.textContent = "Not Active";
paypalStatus.className = "payment-status not-active";
paypalCard.onclick = setupPayPalAccount;
paypalCard.style.borderColor = "#007BFF";
paypalCard.classList.add("pulse-animation");

generateBtn.classList.add("disabled");
generateBtn.onclick = function() {
showToast("Please set up your PayPal account first", "error");
};

paymentWarning.style.display = "block";
}
});
}

// UPDATED: Price calculation with 12% fee instead of 15%
const handlePriceCalculation = debounce(function() {
  const priceInput = document.getElementById('productPrice');
  const priceCalculation = document.getElementById('priceCalculation');
  const basePrice = document.getElementById('basePrice');
  const referralFee = document.getElementById('referralFee');
  const transactionFee = document.getElementById('transactionFee');
  const sellerEarnings = document.getElementById('sellerEarnings');

  const price = parseFloat(priceInput.value);

  if (isNaN(price) || price <= 0) {
    priceCalculation.style.display = 'none';
    return;
  }

  // Commission de 12%
  const refFee = price * 0.12;

  // Frais Stripe: 2.9% + 0.30$
  const stripeFees = (price * 0.029) + 0.30;

  const earnings = price - refFee - stripeFees;

  // Mise à jour de l'interface
  requestAnimationFrame(() => {
    basePrice.textContent = `$${formatCurrency(price)}`;
    referralFee.textContent = `$${formatCurrency(refFee)}`;
    transactionFee.textContent = `$${formatCurrency(stripeFees)}`;
    sellerEarnings.textContent = `$${formatCurrency(earnings)}`;
    priceCalculation.style.display = 'block';
  });
}, 100);

// Update file type icons based on selected category
function updateFileTypeIcons(category) {
const productFileIcon = document.getElementById("productFileIcon");
const fileUploadLimits = document.getElementById("fileUploadLimits");
const fileInput = document.getElementById("productFile");
const productFileUploadBox = document.getElementById("productFileUploadBox");

if (!productFileIcon || !fileUploadLimits || !fileInput || !productFileUploadBox) return;

if (!category) {
// Disable product file upload if no category selected
productFileUploadBox.classList.add("file-disabled");
fileInput.disabled = true;
fileUploadLimits.textContent = "Please select a category first";
productFileIcon.className = "fas fa-file file-upload-icon";
return;
}

// Enable product file upload once category is selected
productFileUploadBox.classList.remove("file-disabled");
fileInput.disabled = false;

// Update icon based on category
if (category && fileTypeIcons[category]) {
productFileIcon.className = fileTypeIcons[category] + " file-upload-icon";
} else {
productFileIcon.className = "fas fa-file file-upload-icon";
}

// Update file size limits based on category
if (category === "video") {
fileUploadLimits.textContent = "Max: 500MB for video content";
fileInput.accept = ".mp4,.mov,.avi,.webm,.mkv";
} else if (category === "ebook") {
fileUploadLimits.textContent = "Max: 100MB for e-books";
fileInput.accept = ".pdf,.epub";
} else if (category === "music") {
fileUploadLimits.textContent = "Max: 100MB for music/songs";
fileInput.accept = ".mp3,.wav,.ogg,.flac";
} else if (category === "software") {
fileUploadLimits.textContent = "Max: 100MB for software files";
fileInput.accept = ".zip,.rar,.7z,.tar,.gz";
} else {
fileUploadLimits.textContent = "Max: 500MB for videos, 100MB for other files";
fileInput.accept = "";
}

// Reset file input if category changed
if (productFile) {
const fileExtension = productFile.name.split('.').pop().toLowerCase();
const categoryExtensions = allowedExtensions[category] || [];

if (!categoryExtensions.includes(fileExtension)) {
productFile = null;
fileInput.value = "";
document.getElementById("productFileName").textContent = "";
document.getElementById("productFileName").style.display = "none";
document.getElementById("productFileSuccessIcon").style.display = "none";
}
}
}

// Optimized product modal opening - MODIFIED: Clear previous product data
function openProductModal() {
const createProductModal = document.getElementById("createProductModal");
const createProductBtn = document.getElementById("createProductBtn");

// Reset form fields
document.getElementById("productTitle").value = "";
document.getElementById("productCategory").value = "";
document.getElementById("productDescription").value = "";
document.getElementById("productPrice").value = "";
document.getElementById("descriptionCharCount").textContent = "0";

// Reset file uploads
coverFile = null;
productFile = null;
document.getElementById("coverFileName").textContent = "";
document.getElementById("coverFileName").style.display = "none";
document.getElementById("coverSuccessIcon").style.display = "none";
document.getElementById("productFileName").textContent = "";
document.getElementById("productFileName").style.display = "none";
document.getElementById("productFileSuccessIcon").style.display = "none";

// Initially disable product file upload
updateFileTypeIcons("");

// Initialize price calculation
document.getElementById("priceCalculation").style.display = "none";

// Reset upload progress
document.getElementById("coverProgressContainer").style.display = "none";
document.getElementById("productProgressContainer").style.display = "none";

createProductBtn.disabled = false;
createProductBtn.innerHTML = 'Generate Link';

// Réinitialiser l'état de création de produit
isProductCreationInProgress = false;

// Display modal after preparation
createProductModal.style.display = "flex";
}

// Optimized links modal opening - MODIFIED: Ne pas rafraîchir les statistiques
async function openLinksModal() {
const linksModal = document.getElementById("linksModal");
const linksList = document.getElementById("linksList");

// First display modal with skeleton loader for speed perception
linksList.innerHTML = '<div style="text-align: center;"><div class="skeleton-loader" style="height: 50px; margin-bottom: 10px;"></div><div class="skeleton-loader" style="height: 50px; margin-bottom: 10px;"></div></div>';
linksModal.style.display = "flex";

try {
// Use the API request helper with minimal processing
const data = await apiRequest('getLinks');
const links = data.links || [];

// Sort links with newest first
links.sort((a, b) => {
if (!a.createdAt || !b.createdAt) return 0;
return new Date(b.createdAt) - new Date(a.createdAt);
});

generatedLinks = links;
displayLinks(links);
} catch (error) {
console.error("Error loading links:", error);
linksList.innerHTML = '<div style="text-align: center; color: #F44336;">Error loading links</div>';
}
}

// UPDATED: Links display function - Updated to clarify the share button
function displayLinks(links) {
const linksList = document.getElementById("linksList");

if (links.length === 0) {
linksList.innerHTML = '<div style="text-align: center; color: #888;">No links generated yet</div>';
return;
}

// Reset click counter for product deletion
productClickCount = {};

// Create a fragment to minimize reflows
const fragment = document.createDocumentFragment();

links.forEach((link, index) => {
const linkItem = document.createElement('div');
linkItem.className = 'link-item';
linkItem.innerHTML = `
<span class="link-number">${index + 1})</span>
<a href="${link.shareableLink}" class="link-title" data-product-id="${link.id}" title="${link.title}">${link.title}</a>
<button class="share-link-btn" data-link="${link.shareableLink}" data-product-id="${link.id}">
<i class="fas fa-arrow-right"></i>
</button>
`;
fragment.appendChild(linkItem);
});

// Clear current list and add fragment
linksList.innerHTML = '';
linksList.appendChild(fragment);

// Add event handlers for share buttons
document.querySelectorAll('.share-link-btn').forEach(btn => {
btn.addEventListener('click', function() {
const link = this.getAttribute('data-link');
const productId = this.getAttribute('data-product-id');

if (navigator.share) {
navigator.share({
title: 'Check out my product',
url: link
}).then(() => {
showToast("Link shared successfully!", "success");
}).catch(err => {
console.error("Share failed:", err);
navigator.clipboard.writeText(link).then(() => {
showToast("Link copied to clipboard!", "success");
});
});
} else {
navigator.clipboard.writeText(link).then(() => {
showToast("Link copied to clipboard!", "success");
});
}
});
});

// Make the title clickable to navigate to the product
document.querySelectorAll('.link-title').forEach(title => {
title.addEventListener('click', function(e) {
e.preventDefault();
window.open(this.getAttribute('href'), '_blank');
});
});
}

// Show delete product confirmation
function showDeleteProductConfirmation(productId, productTitle) {
const confirmModal = document.getElementById("confirmDeleteProductModal");
const confirmDeleteBtn = document.getElementById("confirmDeleteProductBtn");
const cancelDeleteBtn = document.getElementById("cancelDeleteProductBtn");

// Set up event handlers
confirmDeleteBtn.onclick = () => deleteProduct(productId);
cancelDeleteBtn.onclick = () => confirmModal.style.display = "none";

// Update modal text
document.querySelector("#confirmDeleteProductModal .modal-message").textContent = 
    `Are you sure you want to delete "${productTitle}"? This action cannot be undone.`;

// Show modal
confirmModal.style.display = "flex";
}

// Delete a product
async function deleteProduct(productId) {
try {
    const confirmModal = document.getElementById("confirmDeleteProductModal");
    confirmModal.style.display = "none";
    
    // Show loading spinner
    const confirmDeleteBtn = document.getElementById("confirmDeleteProductBtn");
    confirmDeleteBtn.innerHTML = '<span class="spinner"></span> Deleting...';
    
    showToast("Deleting product...", "info");
    
    // Get product data first to know which files to delete
    const productRef = doc(db, "products", productId);
    const productDoc = await getDoc(productRef);
    
    if (!productDoc.exists()) {
        throw new Error("Product not found");
    }
    
    const productData = productDoc.data();
    
    // Delete storage files
    if (productData.coverPath) {
        const coverRef = ref(storage, productData.coverPath);
        await deleteObject(coverRef);
    }
    
    if (productData.filePath) {
        const fileRef = ref(storage, productData.filePath);
        await deleteObject(fileRef);
    }
    
    // Delete the product document
    await deleteDoc(productRef);
    
    showToast("Product deleted successfully", "success");
    
    // Refresh the links list
    await refreshLinksList(auth.currentUser.uid);
    
    // Close the links modal and reopen it to show updated list
    document.getElementById("linksModal").style.display = "none";
    setTimeout(() => openLinksModal(), 500);
    
} catch (error) {
    console.error("Error deleting product:", error);
    showToast("Error deleting product: " + error.message, "error");
} finally {
    // Reset the button
    const confirmDeleteBtn = document.getElementById("confirmDeleteProductBtn");
    confirmDeleteBtn.innerHTML = 'Delete';
}
}

// UPDATED: Modified product creation to prevent incomplete products and handle user exit
async function createProduct() {
if (isSubmitting || isProductCreationInProgress) return;

try {
const createProductBtn = document.getElementById("createProductBtn");
const generationOverlay = document.getElementById("generationOverlay");
const generationStep = document.getElementById("generationStep");
const generationProgressBar = document.getElementById("generationProgressBar");

const user = auth.currentUser;
if (!user) {
showToast("Please log in to create a product", "error");
return;
}

const title = document.getElementById("productTitle").value.trim();
const category = document.getElementById("productCategory").value;
const description = document.getElementById("productDescription").value.trim();
const price = parseFloat(document.getElementById("productPrice").value);

// Validations
if (!title) {
showToast("Please enter a product title", "error");
return;
}

if (!category) {
showToast("Please select a category", "error");
return;
}

if (!description) {
showToast("Please enter a description", "error");
return;
}

if (isNaN(price) || price < 1) {  // Modifié: minimum est maintenant $1 au lieu de $2.99
showToast("Please enter a valid price (minimum $1)", "error");
return;
}

if (!coverFile) {
showToast("Please upload a cover image", "error");
return;
}

if (!productFile) {
showToast("Please upload your product file", "error");
return;
}

// Validate file size based on category
if (category === "video" && productFile.size > 500 * 1024 * 1024) {
showToast("Video files must be less than 500MB", "error");
return;
}

if (category !== "video" && productFile.size > 100 * 1024 * 1024) {
showToast("Files must be less than 100MB for this category", "error");
return;
}

// Validate file type based on category
const fileExtension = productFile.name.split('.').pop().toLowerCase();
const categoryExtensions = allowedExtensions[category] || [];

if (!categoryExtensions.includes(fileExtension)) {
showToast(`Invalid file type for ${category}. Allowed types: ${categoryExtensions.join(', ')}`, "error");
return;
}

// Check if user has set up PayPal
if (!paypalAccountComplete) {
showToast("Please set up your PayPal account first", "error");
setupPayPalAccount();
return;
}

isSubmitting = true;
isProductCreationInProgress = true; // Marquer que la création est en cours
createProductBtn.disabled = true;
createProductBtn.innerHTML = '<span class="spinner"></span> Generating...';

// Hide product modal
document.getElementById("createProductModal").style.display = "none";

// Show improved generation overlay
generationOverlay.style.display = "flex";
generationStep.textContent = "Preparing files...";
// Réinitialiser la barre de progression
generationProgressBar.style.width = "0%";

// Mettre à jour la barre de progression - démarrage
updateGenerationProgress(5);

// Listener for window close/change
const beforeUnloadHandler = (e) => {
  if (isProductCreationInProgress) {
    e.preventDefault();
    e.returnValue = "You have a product upload in progress. Are you sure you want to leave?";
    return e.returnValue;
  }
};
window.addEventListener('beforeunload', beforeUnloadHandler);

// First create the product entry in Firestore without paths yet
const productData = {
uid: user.uid,
title,
category: category || "general",
description: description || "",
price,
fileName: productFile.name,
createdAt: new Date().toISOString(),
sales: 0,
revenue: 0
};

// Update generation step
generationStep.textContent = "Creating product entry...";
// Mettre à jour la barre de progression
updateGenerationProgress(15);

// Use the API to create a placeholder product document
const response = await apiRequest('createProduct', 'POST', productData);

if (!response.success) {
throw new Error(response.error || 'Failed to create product');
}

const productId = response.productId;
const shareableLink = response.shareableLink;

// Define storage paths
const coverPath = `covers/${user.uid}/${Date.now()}_cover_${coverFile.name}`;
const productPath = `products/${user.uid}/${Date.now()}_${productFile.name}`;

// Update generation step
generationStep.textContent = "Uploading cover image...";
// Mettre à jour la barre de progression
updateGenerationProgress(25);

// Parallel file uploads for better performance
const [coverStorageRef, productStorageRef] = [
ref(storage, coverPath),
ref(storage, productPath)
];

// Start cover upload
const uploadCover = uploadBytesResumable(coverStorageRef, coverFile);

// Listen for upload progress
uploadCover.on('state_changed', 
  (snapshot) => {
    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
    // Mettre à jour la barre de progression pour le cover (25% à 50%)
    updateGenerationProgress(25 + Math.floor(progress * 0.25));
    
    if (progress > 95) {
      generationStep.textContent = "Cover uploaded, processing product file...";
    }
  },
  (error) => {
    console.error("Error uploading cover:", error);
  }
);

// Wait for cover upload to complete
await uploadCover.then();

// Update generation step
generationStep.textContent = "Uploading product file...";
// Mettre à jour la barre de progression
updateGenerationProgress(50);

// Start product file upload
const uploadProduct = uploadBytesResumable(productStorageRef, productFile);

// Listen for upload progress
uploadProduct.on('state_changed', 
  (snapshot) => {
    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
    // Mettre à jour la barre de progression pour le fichier produit (50% à 90%)
    updateGenerationProgress(50 + Math.floor(progress * 0.4));
    
    if (progress > 95) {
      generationStep.textContent = "Product file uploaded, finalizing...";
    }
  },
  (error) => {
    console.error("Error uploading product file:", error);
  }
);

// Wait for product upload to complete
await uploadProduct.then();

// Get download URLs for verification
const [coverDownloadUrl, productDownloadUrl] = await Promise.all([
getDownloadURL(coverStorageRef),
getDownloadURL(productStorageRef)
]);

// Update generation step
generationStep.textContent = "Finalizing your product...";
// Mettre à jour la barre de progression
updateGenerationProgress(95);

// Update the product document with the actual storage paths
const productRef = doc(db, "products", productId);
await updateDoc(productRef, {
coverPath: coverPath,
filePath: productPath,
shareableLink: shareableLink
});

// Update link count in database
await updateUserStats(user.uid, 'linksCount', 1, true);

// Refresh generated links list
await refreshLinksList(user.uid);

// Mettre à jour la barre de progression à 100%
updateGenerationProgress(100);

// Hide generation overlay
setTimeout(() => {
  generationOverlay.style.display = "none";
  isProductCreationInProgress = false; // Marquer que la création est terminée
}, 500);

// Remove beforeunload listener
window.removeEventListener('beforeunload', beforeUnloadHandler);

showToast("Product created successfully!", "success");

// Show modal with link
const linkModal = document.createElement("div");
linkModal.className = "modal";
linkModal.style.display = "flex";
linkModal.innerHTML = `
<div class="modal-content">
<div class="modal-title" style="color: #007BFF;">Link Generated Successfully</div>
<div style="margin: 20px 0;">Your product link has been created and is ready to share!</div>
<button id="copyLinkBtn" class="create-product-button">Copy Link</button>
<button id="closeLinkModalBtn" class="cancel-button">Close</button>
</div>
`;

document.body.appendChild(linkModal);

document.getElementById("copyLinkBtn").addEventListener("click", function() {
navigator.clipboard.writeText(shareableLink).then(() => {
showToast("Link copied to clipboard!", "success");
});
});

document.getElementById("closeLinkModalBtn").addEventListener("click", function() {
linkModal.remove();
});

setTimeout(() => {
if (document.body.contains(linkModal)) {
linkModal.remove();
}
}, 15000); // Close after 15 seconds instead of 30

// Reset form values for next product
coverFile = null;
productFile = null;

} catch (error) {
console.error("Error creating product:", error);
showToast(`Error: ${error.message || "Unknown error"}`, "error");

// Hide generation overlay on error
document.getElementById("generationOverlay").style.display = "none";
isProductCreationInProgress = false;
} finally {
isSubmitting = false;
const createProductBtn = document.getElementById("createProductBtn");
if (createProductBtn) {
  createProductBtn.disabled = false;
  createProductBtn.innerHTML = 'Generate Link';
}
}
}

// Nouvelle fonction pour mettre à jour la barre de progression
function updateGenerationProgress(percent) {
  const progressBar = document.getElementById("generationProgressBar");
  if (progressBar) {
    progressBar.style.width = percent + "%";
    
    // Changer la couleur en fonction de la progression
    if (percent < 30) {
      progressBar.style.backgroundColor = "#ff9800"; // Orange
    } else if (percent < 70) {
      progressBar.style.backgroundColor = "#2196F3"; // Bleu
    } else {
      progressBar.style.backgroundColor = "#4CAF50"; // Vert
    }
  }
}

// Optimized user stats update
async function updateUserStats(userId, statField, value, increment = true) {
// Unique key for this update
const updateKey = `${userId}_${statField}_${value}_${increment}`;

// Check if we already have a pending update for this stat
if (pendingUpdates[updateKey]) {
return pendingUpdates[updateKey];
}

try {
// Create a promise for this update
pendingUpdates[updateKey] = new Promise(async (resolve, reject) => {
try {
const statsRef = doc(db, "userStats", userId);
const statsDoc = await getDoc(statsRef);

if (statsDoc.exists()) {
// Update specific stat
if (increment) {
await updateDoc(statsRef, {
[statField]: (statsDoc.data()[statField] || 0) + value,
lastUpdated: serverTimestamp()
});
} else {
await updateDoc(statsRef, {
[statField]: value,
lastUpdated: serverTimestamp()
});
}

console.log(`Updated ${statField} for user ${userId}`);
resolve(true);
} else {
// Create document if it doesn't exist
await initializeUserStats(userId);
const result = await updateUserStats(userId, statField, value, increment);
resolve(result);
}
} catch (error) {
console.error(`Error updating ${statField}:`, error);
reject(error);
} finally {
// Remove this update from pending updates
delete pendingUpdates[updateKey];
}
});

return await pendingUpdates[updateKey];
} catch (error) {
console.error(`Error in updateUserStats for ${statField}:`, error);
delete pendingUpdates[updateKey];
return false;
}
}

// Optimized links list refresh
async function refreshLinksList(userId) {
try {
// Use the API request helper
const data = await apiRequest('getLinks');
generatedLinks = data.links || [];

// Sort links with newest first
generatedLinks.sort((a, b) => {
if (!a.createdAt || !b.createdAt) return 0;
return new Date(b.createdAt) - new Date(a.createdAt);
});

// Get count of all links
const linksCount = generatedLinks.length;

// Update links counter in interface
updateCountWithImprovedTrend("linksCount", "linksIndicator", linksCount, "", previousUserData?.linksCount);

// Update local user data
if (currentUserData) {
previousUserData = {...currentUserData};
currentUserData.linksCount = linksCount;
}

// Update Firestore directly too
await updateUserStats(userId, 'linksCount', linksCount, false);

return generatedLinks;
} catch (error) {
console.error("Error refreshing links:", error);
return generatedLinks || [];
}
}

// Improved trend indicator function avec formatage des décimales
function updateCountWithImprovedTrend(elementId, indicatorId, value, suffix, previousValue) {
const element = document.getElementById(elementId);
const indicator = document.getElementById(indicatorId);

if (!element || !indicator) return;

const currentText = element.textContent;
const currentValue = currentText.replace(/[^0-9.-]+/g, "");

const valueChanged = currentValue !== "" && parseFloat(currentValue) !== value;

// Use requestAnimationFrame for visual updates
requestAnimationFrame(() => {
if (valueChanged) {
animateUpdate(element);

// Afficher la flèche verte vers le haut si une vente a eu lieu récemment
// Ou si le compte a augmenté
if (currentUserData?.hasSaleInLast24h || (previousValue !== undefined && value > previousValue)) {
  indicator.className = "trend-indicator trend-up";
  indicator.innerHTML = '<i class="fas fa-arrow-up"></i>';
} else if (previousValue !== undefined && value < previousValue) {
  // Afficher la flèche rouge vers le bas si diminution
  indicator.className = "trend-indicator trend-down";
  indicator.innerHTML = '<i class="fas fa-arrow-down"></i>';
} else {
  // Pas de flèche si égalité
  indicator.className = "trend-indicator";
  indicator.innerHTML = '';
}
}

// Formatage des revenus avec 2 décimales maximum
if (elementId === "revenueCount") {
element.textContent = formatCurrency(value) + "$";
} else {
element.textContent = value + suffix;
}
});
}

// Optimized auth state listener avec vérification des payouts
auth.onAuthStateChanged(async (user) => {
if (user) {
try {
showAllDataLoaders(true);

// Clean up previous listeners
cleanupListeners();

// Get authentication token
userIdToken = await getValidToken();

// Initialize user stats if needed
await initializeUserStats(user.uid);

// NOUVEAU: Vérifier les payouts automatiques
await checkAndHandlePayout();

// PayPal status check - do this first for better UX
const paypalStatus = await checkPayPalStatus();

// Initialize with annual data
updatePeriodDisplay();

// Reset trend indicators on initial load
resetTrendIndicators();

// Force direct database refresh on first load
await Promise.all([
forceDirectOrdersRefresh(user.uid),
forceDirectViewsRefresh(user.uid)
]);
lastOrdersRefresh = Date.now();

// Parallel user data loading
const loadDataPromises = [
loadUserData(user.uid),
loadLinksData(user.uid)
];

await Promise.all(loadDataPromises);

// Set up real-time listeners
setupRealTimeListeners(user.uid);

showAllDataLoaders(false);
lastDataRefresh = Date.now();

if (isInitialLoad) {
isInitialLoad = false;
showToast("Welcome to your dashboard!", "success");
}

setupDataRefresh();

} catch (error) {
console.error("Error during initialization:", error);
showAllDataLoaders(false);
showToast("An error occurred. Please try again.", "error");
}
} else {
window.location.href = "auth.html";
}
});

// Optimized listeners cleanup
function cleanupListeners() {
realTimeListeners.forEach(unsubscribe => unsubscribe());
realTimeListeners = [];
}

// Optimized user data loading avec récupération du balance
async function loadUserData(userId) {
if (!userId) {
throw new Error("User ID is required");
}

try {
// Use the API request helper
try {
const response = await apiRequest('getUserData');

if (!response.success) {
throw new Error("Failed to load user data");
}

const userData = response.data;

// Save previous state for comparison
previousUserData = currentUserData ? {...currentUserData} : null;
currentUserData = userData;

// Update user interface
updateDashboardUI(userData);

return userData;
} catch (apiError) {
console.error("API Error loading user data:", apiError);

// Fallback to Firestore
const userDocRef = doc(db, "users", userId);
const userDoc = await getDoc(userDocRef);

if (!userDoc.exists()) {
throw new Error("User data not found");
}

const userData = userDoc.data();

// Load stats from userStats collection
const statsRef = doc(db, "userStats", userId);
const statsDoc = await getDoc(statsRef);

if (statsDoc.exists()) {
const stats = statsDoc.data();

// Merge stats with user data
userData.linksCount = stats.linksCount || 0;
userData.viewsCount = stats.viewsCount || 0;
userData.ordersCount = stats.ordersCount || 0;
userData.shippedCount = stats.shippedCount || 0;
// Utilise le balance au lieu de revenueCount des stats
userData.revenueCount = userData.balance || 0;
}

// Save previous state for comparison
previousUserData = currentUserData ? {...currentUserData} : null;
currentUserData = userData;

// Update user interface
updateDashboardUI(userData);

return userData;
}
} catch (error) {
console.error("Error loading user data:", error);

// Final fallback to minimal data
if (!currentUserData) {
currentUserData = {
uid: userId,
linksCount: 0,
viewsCount: 0,
ordersCount: 0,
shippedCount: 0,
revenueCount: 0
};
}

throw error;
}
}

// Real-time listeners setup avec gestion des payouts
function setupRealTimeListeners(userId) {
try {
// Listener for user updates
const userDocRef = doc(db, "users", userId);
const userUnsubscribe = onSnapshot(userDocRef, (doc) => {
if (doc.exists()) {
previousUserData = currentUserData ? {...currentUserData} : null;

// Preserve existing stats but update balance from users collection
const existingStats = currentUserData ? {
linksCount: currentUserData.linksCount,
viewsCount: currentUserData.viewsCount,
ordersCount: currentUserData.ordersCount,
shippedCount: currentUserData.shippedCount
} : {};

const userData = doc.data();
currentUserData = {...userData, ...existingStats};
// Le revenueCount vient maintenant du balance des users
currentUserData.revenueCount = userData.balance || 0;

// Vérifier les payouts
if (userData.lastPayout && previousUserData) {
const prevLastPayout = previousUserData.lastPayout;
const currentLastPayout = userData.lastPayout;

// Si lastPayout a changé, c'est qu'un nouveau payout a eu lieu
if (!prevLastPayout || (currentLastPayout && currentLastPayout !== prevLastPayout)) {
console.log("New payout detected!");
checkAndHandlePayout();
}
}

// Check if PayPal status changed
const paypalEmailChanged =
(previousUserData?.paypalEmail !== currentUserData.paypalEmail) &&
(currentUserData.paypalEmail !== undefined);

if (paypalEmailChanged) {
updatePayPalUI(!!currentUserData.paypalEmail);
}

// Check for last sale timestamp updates
const lastSaleChanged = 
previousUserData && 
previousUserData.lastSale !== currentUserData.lastSale &&
currentUserData.lastSale;

// Force refresh of order data when a new sale is detected
if (lastSaleChanged) {
console.log("New sale detected, forcing data refresh");
forceDirectOrdersRefresh(userId);
}

updateDashboardUI(currentUserData);
}
});

// Enhanced listener for user stats with more responsive updates
const statsRef = doc(db, "userStats", userId);
const statsUnsubscribe = onSnapshot(statsRef, (doc) => {
if (doc.exists() && currentUserData) {
const stats = doc.data();

// Save previous values for comparison
previousUserData = {...currentUserData};

// Update current user data with new stats (sauf revenueCount qui vient du balance)
currentUserData.linksCount = stats.linksCount || 0;
currentUserData.viewsCount = stats.viewsCount || 0;
currentUserData.ordersCount = stats.ordersCount || 0;
currentUserData.shippedCount = stats.shippedCount || 0;
// Ne pas écraser revenueCount qui vient déjà du balance

// Update interface with new stats using improved trend indicators
updateDashboardUI(currentUserData);
}
});

// Listen directly to orders collection changes for the seller
const ordersQuery = query(
collection(db, "orders"),
where("sellerUid", "==", userId),
orderBy("createdAt", "desc"),
limit(20)
);

const ordersUnsubscribe = onSnapshot(ordersQuery, (snapshot) => {
// Force direct refresh of orders data when orders change
forceDirectOrdersRefresh(userId);
});

// Listen to product views collection to update view count
const productsQuery = query(
collection(db, "products"),
where("uid", "==", userId)
);

const productsUnsubscribe = onSnapshot(productsQuery, async (snapshot) => {
// Update links count when products change
const linksCount = snapshot.size;
if (currentUserData) {
currentUserData.linksCount = linksCount;
updateCountWithImprovedTrend("linksCount", "linksIndicator", linksCount, "", previousUserData?.linksCount);
}

// Force refresh of views data
await forceDirectViewsRefresh(userId);
});

// Listener for transactions pour l'année
const currentYear = new Date().getFullYear();
const startOfYear = new Date(currentYear, 0, 1);
const endOfYear = new Date(currentYear, 11, 31, 23, 59, 59, 999);

const transactionsQuery = query(
collection(db, "transactions"),
where("userId", "==", userId),
where("date", ">=", Timestamp.fromDate(startOfYear)),
where("date", "<=", Timestamp.fromDate(endOfYear)),
orderBy("date", "desc"),
limit(20)
);

const transactionsUnsubscribe = onSnapshot(transactionsQuery, (snapshot) => {
if (snapshot.empty) {
if (currentUserData) {
currentUserData.transactions = [];
// Ne pas mettre à jour la liste des transactions si vide (utiliser lastTransactions)
if (lastTransactions.length === 0) {
  updateTransactionList([]);
}
}
return;
}

const transactions = [];
snapshot.forEach(doc => {
transactions.push({
id: doc.id,
...doc.data()
});
});

// Mettre à jour les transactions
if (currentUserData) {
currentUserData.transactions = transactions;
updateTransactionList(transactions);
// Mémoriser les transactions
lastTransactions = transactions;
}
});

// Add unsubscribe functions for later cleanup
realTimeListeners.push(userUnsubscribe);
realTimeListeners.push(statsUnsubscribe);
realTimeListeners.push(ordersUnsubscribe);
realTimeListeners.push(productsUnsubscribe);
realTimeListeners.push(transactionsUnsubscribe);
} catch (error) {
console.error("Error setting up real-time listeners:", error);
}
}

// Optimized links data loading pour année
async function loadLinksData(userId) {
try {
// Use the API request helper
const data = await apiRequest('getLinks');
const links = data.links || [];

// Sort links with newest first
links.sort((a, b) => {
if (!a.createdAt || !b.createdAt) return 0;
return new Date(b.createdAt) - new Date(a.createdAt);
});

generatedLinks = links;

// Get count of all links
const linksCount = links.length;

// Update links counter in database
await updateUserStats(userId, 'linksCount', linksCount, false);

// Update links counter in dashboard
if (currentUserData) {
currentUserData.linksCount = linksCount;
updateCountWithImprovedTrend("linksCount", "linksIndicator", linksCount, "", previousUserData?.linksCount);
}

return links;
} catch (error) {
console.error("Error loading links data:", error);
throw error;
}
}

// Dashboard interface update avec formatage des revenus
function updateDashboardUI(userData) {
if (!userData) return;

// Group DOM updates in a single render cycle
requestAnimationFrame(() => {
// Use improved trend indicators avec formatage des décimales
updateCountWithImprovedTrend("linksCount", "linksIndicator", userData.linksCount || 0, "", previousUserData?.linksCount);
updateCountWithImprovedTrend("viewsCount", "viewsIndicator", userData.viewsCount || 0, "", previousUserData?.viewsCount);
updateCountWithImprovedTrend("ordersCount", "ordersIndicator", userData.ordersCount || 0, "", previousUserData?.ordersCount);
updateCountWithImprovedTrend("shippedCount", "shippedIndicator", userData.shippedCount || 0, "", previousUserData?.shippedCount);
updateCountWithImprovedTrend("revenueCount", "revenueIndicator", userData.revenueCount || 0, "$", previousUserData?.revenueCount);
});

// Slightly delay transaction list update to spread the load
setTimeout(() => {
if (userData.transactions && userData.transactions.length > 0) {
  updateTransactionList(userData.transactions);
  lastTransactions = userData.transactions;
} else if (lastTransactions.length > 0) {
  // Utiliser les transactions mémorisées
  updateTransactionList(lastTransactions);
}
}, 50);
}

// MODIFIÉ: Transactions list update avec formatage des montants et nom des produits
const updateTransactionList = debounce(function(transactions = []) {
const transactionList = document.getElementById("transactionList");
if (!transactionList) return;

// Create a fragment to minimize reflows
const fragment = document.createDocumentFragment();

if (!transactions || transactions.length === 0) {
const noTransactions = document.createElement("div");
noTransactions.className = "no-transactions";
noTransactions.textContent = "No transactions for this period";
fragment.appendChild(noTransactions);

transactionList.innerHTML = "";
transactionList.appendChild(fragment);
return;
}

// Filter and sort transactions
let filteredTransactions = transactions
.sort((a, b) => {
const dateA = a.date ? (a.date.toDate ? a.date.toDate() : new Date(a.date)) : new Date();
const dateB = b.date ? (b.date.toDate ? b.date.toDate() : new Date(b.date)) : new Date();
return dateB - dateA;
});

if (filteredTransactions.length === 0) {
const noTransactions = document.createElement("div");
noTransactions.className = "no-transactions";
noTransactions.textContent = "No transactions for this period";
fragment.appendChild(noTransactions);
} else {
// Limit to 30 transactions maximum for better performance
filteredTransactions = filteredTransactions.slice(0, 5);

filteredTransactions.forEach(transaction => {
const date = transaction.date ?
(transaction.date.toDate ? transaction.date.toDate() : new Date(transaction.date)) :
new Date();

const formattedDate = `${date.getDate()}/${date.getMonth() + 1}/${date.getFullYear()}`;

const item = document.createElement("div");
item.className = "transaction-item";

// NOUVEAU: Formatage des montants avec 2 décimales maximum
const formattedAmount = formatCurrency(transaction.amount || 0);

// Style based on transaction type with category display
if (transaction.type === "sale") {
item.classList.add("sold-transaction");
// NOUVEAU: Afficher le type de produit vendu
const productType = transaction.category ? `Sale ${transaction.category}` : "Sale";
item.innerHTML = `
<div class="details">
<span>${productType}</span>
<span class="date">${formattedDate}</span>
</div>
<span class="price">$${formattedAmount}</span>
`;
} else if (transaction.type === "payout") {
item.classList.add("payout-transaction");
item.innerHTML = `
<div class="details">
<span>Payout</span>
<span class="date">${formattedDate}</span>
</div>
<span class="price">$${formattedAmount}</span>
`;
} else {
if (transaction.status === "shipped" || transaction.status === "delivered") {
item.style.borderLeft = "3px solid #4CAF50";
} else if (transaction.status === "pending") {
item.style.borderLeft = "3px solid #FFC107";
} else if (transaction.status === "cancelled") {
item.style.borderLeft = "3px solid #F44336";
item.style.opacity = "0.7";
}

item.innerHTML = `
<div class="details">
<span>${transaction.title || "Unspecified transaction"}</span>
<span class="date">${formattedDate}</span>
</div>
<span class="price">$${formattedAmount}</span>
`;
}

fragment.appendChild(item);
});
}

// Update DOM in a single operation
transactionList.innerHTML = "";
transactionList.appendChild(fragment);

// Ensure newest transactions are visible
transactionList.scrollTop = 0;
}, 150);

// User account and data deletion
async function deleteAccount(email, password) {
try {
const user = auth.currentUser;
if (!user) {
throw new Error("User not logged in");
}

// Update UI to show process is happening
const confirmDeleteBtn = document.getElementById("confirmDeleteBtn");
confirmDeleteBtn.innerHTML = '<span class="spinner"></span> Deleting...';
showToast("Deleting account...", "info");

// Re-authenticate user before deletion
const credential = EmailAuthProvider.credential(email, password);
await reauthenticateWithCredential(user, credential);

// Use the API request helper
await apiRequest('deleteUserAccount', 'POST', { uid: user.uid });

// Delete user's authentication account
await deleteUser(user);

showToast("Account deleted successfully", "success");
setTimeout(() => {
window.location.href = "auth.html";
}, 1500);
} catch (error) {
console.error("Error deleting account:", error);

// Reset button
const confirmDeleteBtn = document.getElementById("confirmDeleteBtn");
confirmDeleteBtn.innerHTML = 'Delete';

if (error.code === 'auth/wrong-password') {
showToast("Incorrect password", "error");
} else if (error.code === 'auth/user-mismatch') {
showToast("Email doesn't match current user", "error");
} else if (error.code === 'auth/invalid-email') {
showToast("Invalid email format", "error");
} else {
showToast("Error deleting account: " + error.message, "error");
}

throw error;
}
}

// Set up event listeners
document.addEventListener('DOMContentLoaded', function() {
const profileIcon = document.getElementById("profileIcon");
const linksIcon = document.getElementById("linksIcon");
const deleteModal = document.getElementById("deleteModal");
const confirmModal = document.getElementById("confirmModal");
const deleteAccountBtn = document.getElementById("deleteAccountBtn");
const confirmDeleteBtn = document.getElementById("confirmDeleteBtn");
const cancelDeleteBtn = document.getElementById("cancelDeleteBtn");
const emailInput = document.getElementById("emailInput");
const passwordInput = document.getElementById("passwordInput");
const generateBtn = document.getElementById("generateBtn");
const paypalCard = document.getElementById("paypalCard");
const savePaypalBtn = document.getElementById("savePaypalBtn");
const closeLinksModal = document.getElementById("closeLinksModal");
const periodSelector = document.getElementById("periodSelector");
const currentPeriod = document.getElementById("currentPeriod");
const periodLoaderIcon = document.getElementById("periodLoaderIcon");

// Add click handler for stats request (icône d'engrenage)
periodLoaderIcon.addEventListener("click", requestStatsEmail);
currentPeriod.addEventListener("click", requestStatsEmail);

// FIXED: Empêcher la mise à jour des statistiques lors de l'ouverture des liens
// Modification pour éviter le bug de mise à jour des stats
linksIcon.addEventListener("click", function(e) {
  e.preventDefault();
  // Ouvrir le modal des liens sans rafraîchir les statistiques
  openLinksModal();
});

// Use event delegation to reduce number of listeners
document.addEventListener("click", function(e) {
// Product creation modal handling
if (e.target.id === "cancelProductBtn") {
  // Si création de produit en cours, demander confirmation
  if (isProductCreationInProgress) {
    if (confirm("Are you sure you want to cancel? Your product creation is in progress.")) {
      document.getElementById("createProductModal").style.display = "none";
      document.getElementById("generationOverlay").style.display = "none";
      isProductCreationInProgress = false;
    }
  } else {
    document.getElementById("createProductModal").style.display = "none";
  }
}

// Product creation button handling
if (e.target.id === "createProductBtn") {
createProduct();
}
});

document.getElementById("productDescription").addEventListener("input", function() {
const descLength = this.value.length;
document.getElementById("descriptionCharCount").textContent = descLength;
});

document.getElementById("productPrice").addEventListener("input", handlePriceCalculation);

// Listen to category changes to update file types
document.getElementById("productCategory").addEventListener("change", function() {
updateFileTypeIcons(this.value);
});

document.getElementById("coverFile").addEventListener("change", function(e) {
if (e.target.files.length > 0) {
coverFile = e.target.files[0];

if (!coverFile.type.startsWith('image/')) {
showToast("Please upload an image file for the cover", "error");
coverFile = null;
return;
}

if (coverFile.size > 5 * 1024 * 1024) {
showToast("Cover image must be less than 5MB", "error");
coverFile = null;
return;
}

const fileName = document.getElementById("coverFileName");
fileName.textContent = "";
fileName.style.display = "none";

document.getElementById("coverSuccessIcon").style.display = "block";
}
});

document.getElementById("productFile").addEventListener("change", function(e) {
if (e.target.files.length > 0) {
productFile = e.target.files[0];
const category = document.getElementById("productCategory").value;
const fileExtension = productFile.name.split('.').pop().toLowerCase();
const categoryExtensions = allowedExtensions[category] || [];

// Validate file type
if (category && !categoryExtensions.includes(fileExtension)) {
showToast(`Invalid file type for ${category}. Allowed types: ${categoryExtensions.join(', ')}`, "error");
productFile = null;
return;
}

// Validate file size
if (category === "video" && productFile.size > 500 * 1024 * 1024) {
showToast("Video files must be less than 500MB", "error");
productFile = null;
return;
} else if (category !== "video" && productFile.size > 100 * 1024 * 1024) {
showToast("Files must be less than 100MB for this category", "error");
productFile = null;
return;
}

const fileName = document.getElementById("productFileName");
fileName.textContent = "";
fileName.style.display = "none";

document.getElementById("productFileSuccessIcon").style.display = "block";
}
});

savePaypalBtn.addEventListener("click", savePayPalEmail);

closeLinksModal.addEventListener("click", function() {
document.getElementById("linksModal").style.display = "none";
});

window.openProductModal = openProductModal;
window.setupPayPalAccount = setupPayPalAccount;

// Set up PayPal card click handler
paypalCard.addEventListener("click", function() {
if (!paypalAccountComplete) {
setupPayPalAccount();
}
});

generateBtn.addEventListener("click", function(e) {
if (generateBtn.classList.contains("disabled")) {
e.preventDefault();
showToast("Please set up your PayPal account first", "error");

if (!paypalAccountComplete) {
// Simplified animation to avoid performance issues
paypalCard.style.animation = "pulse 1s ease";
}
}
});

profileIcon.addEventListener("click", function() {
deleteModal.style.display = "flex";
});

// Event delegation for clicks outside modals
window.addEventListener("click", function(event) {
if (event.target === deleteModal) {
deleteModal.style.display = "none";
}
if (event.target === confirmModal) {
confirmModal.style.display = "none";
emailInput.value = "";
passwordInput.value = "";
}
if (event.target === document.getElementById("createProductModal")) {
  // Si création de produit en cours, demander confirmation
  if (isProductCreationInProgress) {
    if (confirm("Are you sure you want to cancel? Your product creation is in progress.")) {
      document.getElementById("createProductModal").style.display = "none";
      document.getElementById("generationOverlay").style.display = "none";
      isProductCreationInProgress = false;
    }
  } else {
    document.getElementById("createProductModal").style.display = "none";
  }
}
if (event.target === document.getElementById("linksModal")) {
document.getElementById("linksModal").style.display = "none";
}
if (event.target === document.getElementById("paypalModal")) {
document.getElementById("paypalModal").style.display = "none";
}
if (event.target === document.getElementById("confirmDeleteProductModal")) {
document.getElementById("confirmDeleteProductModal").style.display = "none";
}
});

deleteAccountBtn.addEventListener("click", function() {
deleteModal.style.display = "none";
confirmModal.style.display = "flex";

if (auth.currentUser && auth.currentUser.email) {
emailInput.value = auth.currentUser.email;
}
});

cancelDeleteBtn.addEventListener("click", function() {
confirmModal.style.display = "none";
emailInput.value = "";
passwordInput.value = "";
});

confirmDeleteBtn.addEventListener("click", async function() {
const email = emailInput.value.trim();
const password = passwordInput.value.trim();

if (!email || !password) {
showToast("Please enter your email and password", "error");
return;
}

try {
confirmModal.style.display = "none";
await deleteAccount(email, password);
} catch (error) {
console.error("Error during account deletion:", error);
}
});

// Add a connection status check
window.addEventListener('online', function() {
showToast("Connection restored", "success");
if (auth.currentUser) {
setTimeout(() => {
directDbRefresh = true; // Force direct refresh when back online
refreshDashboardData(auth.currentUser.uid, false);
}, 1000);
}
});

window.addEventListener('offline', function() {
showToast("Connection lost. Working in offline mode", "error");
});

// Ajouter un gestionnaire pour annuler la création du produit si l'utilisateur quitte la page
window.addEventListener('beforeunload', function(e) {
  if (isProductCreationInProgress) {
    e.preventDefault();
    e.returnValue = "You have a product upload in progress. Are you sure you want to leave?";
    return e.returnValue;
  }
});

// Detect idle periods for non-essential tasks
if ('requestIdleCallback' in window) {
requestIdleCallback(() => {
console.log("Application optimized and ready");
});
}

// Manual refresh button (could be added to UI if needed)
window.refreshData = function() {
if (auth.currentUser) {
showToast("Refreshing dashboard data...", "info");
directDbRefresh = true;
refreshDashboardData(auth.currentUser.uid, true);
}
};

// Ajouter un style pour l'animation de rotation de l'engrenage
const style = document.createElement('style');
style.textContent = `
  .spin-animation {
    animation: spin 2s linear infinite;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Style pour les transactions plus compactes */
  .transaction-item {
    font-size: 0.85em;
    padding: 8px;
    margin-bottom: 6px;
  }
  
  .transaction-item .details span {
    font-size: 0.9em;
  }
  
  .transaction-item .date {
    font-size: 0.8em !important;
    color: #666;
  }
  
  .transaction-item .price {
    color: #4CAF50;
    font-weight: bold;
  }
  
  /* Nouveau style pour la barre de progression */
  .generation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10000;
  }
  
  .progress-container {
    width: 80%;
    max-width: 400px;
    background-color: #333;
    height: 20px;
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 20px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
  }
  
  .progress-bar {
    height: 100%;
    background-color: #2196F3;
    width: 0%;
    transition: width 0.5s ease-in-out, background-color 0.5s ease;
    border-radius: 10px;
  }
  
  .generation-message {
    color: #fff;
    font-size: 1.2em;
    margin-bottom: 10px;
    font-weight: bold;
    text-align: center;
  }
  
  .generation-step {
    color: #ccc;
    font-size: 0.9em;
    margin-top: 10px;
    text-align: center;
  }
`;
document.head.appendChild(style);
});
</script>
</body>
</html>
